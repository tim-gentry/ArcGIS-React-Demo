import{ac as n,ad as h,aI as u,ag as f,aJ as p,bA as g,fI as b,fJ as m,fK as w,f0 as y,fL as C,fM as M,dZ as R,f as k}from"./index-DX0rcHuW.js";import{b as P}from"./geodesicUtils-BPlO99Nt.js";var l;let c=l=class extends p{constructor(...e){super(...e),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}normalizeCtorArgs(e,a){let i;if(e!=null&&e.center)i=e;else{if(e!=null&&e.rings)return super.normalizeCtorArgs(e,a);i={center:e}}return{...super.normalizeCtorArgs(),...i,...a}}initialize(){const e=this.center,a=this.numberOfPoints;if(this.hasZ=(e==null?void 0:e.hasZ)??!1,this.rings.length!==0||!e)return;const i=g(this.radius,this.radiusUnit,"meters"),r=e.spatialReference;let s,t="geographic";if(r.isWebMercator?t="webMercator":((r.wkid&&b[r.wkid])!=null||(r.wkt2||r.wkt)&&m(r.wkt2||r.wkt))&&(t="projected"),this.geodesic){let o;switch(t){case"webMercator":o=w(e);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":o=e}s=this._createGeodesicCircle(o,i,a),t==="webMercator"&&(s=y(s))}else{let o;t==="webMercator"||t==="projected"?o=i/C(e.spatialReference):t==="geographic"&&(o=M(i,"meters",R(e.spatialReference).radius)),s=this._createPlanarCircle(e,o,a)}this.spatialReference=s.spatialReference,this.addRing(s.rings[0])}clone(){const{center:e,numberOfPoints:a,radius:i,radiusUnit:r,geodesic:s}=this;return new l({center:e==null?void 0:e.clone(),numberOfPoints:a,radius:i,radiusUnit:r,geodesic:s})}_createGeodesicCircle(e,a,i){let r=0;const s=[];for(;r<360;){const t=[0,0],o=[e.x,e.y];P(t,o,r,a,k.WGS84),this.hasZ&&t.push(e.z),s.push(t),r+=360/i}return s.push(s[0]),new p(s)}_createPlanarCircle(e,a,i){const r=[],s=2*Math.PI/i;for(let t=0;t<i;++t){const o=s*t,d=[e.x+Math.cos(-o)*a,e.y+Math.sin(-o)*a];this.hasZ&&d.push(e.z),r.push(d)}return r.push(r[0]),new p({spatialReference:e.spatialReference,rings:[r]})}};n([h({type:u})],c.prototype,"center",void 0),n([h()],c.prototype,"geodesic",void 0),n([h()],c.prototype,"numberOfPoints",void 0),n([h()],c.prototype,"radius",void 0),n([h()],c.prototype,"radiusUnit",void 0),c=l=n([f("esri.geometry.Circle")],c);const j=c;export{j as b};

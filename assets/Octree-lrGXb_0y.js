import{c2 as he,bb as C,dk as W,d8 as ae,bp as J,d6 as q,d5 as k,dm as G,d2 as _}from"./index-DX0rcHuW.js";import{s as v}from"./frustum-Tc8kkw3_.js";import{T as w,l as U,N as $,H as Q,V as f,_ as B}from"./sphere-COyqsaGw.js";import{i as te}from"./Util-HYkJg9Vp.js";class A{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(e,t){this.objectToBoundingSphere=e,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new d,this._objectCount=0,t&&(t.maximumObjectsPerNode!==void 0&&(this._maximumObjectsPerNode=t.maximumObjectsPerNode),t.maximumDepth!==void 0&&(this._maximumDepth=t.maximumDepth))}destroy(){this._degenerateObjects.clear(),d.clearPool(),K[0]=null,N.prune(),M.prune()}add(e,t=e.length){this._objectCount+=t,this._grow(e,t);const n=d.acquire();for(let o=0;o<t;o++){const s=e[o];this._isDegenerate(s)?this._degenerateObjects.add(s):(n.init(this._root),this._add(s,n))}d.release(n)}remove(e,t=null){this._objectCount-=e.length;const n=d.acquire();for(const o of e){const s=t??w(this.objectToBoundingSphere(o),be);F(s[3])?(n.init(this._root),de(o,s,n)):this._degenerateObjects.delete(o)}d.release(n),this._shrink()}update(e,t){if(!F(t[3])&&this._isDegenerate(e))return;const n=pe(e);this.remove(n,t),this.add(n)}forEachAlongRay(e,t,n){const o=U(e,t);z(this._root,s=>{if(!ue(o,s))return!1;const h=s.node;return h.terminals.forAll(a=>{this._intersectsObject(o,a)&&n(a)}),h.residents!==null&&h.residents.forAll(a=>{this._intersectsObject(o,a)&&n(a)}),!0})}forEachAlongRayWithVerticalOffset(e,t,n,o){const s=U(e,t);z(this._root,h=>{if(!ce(s,h,o))return!1;const a=h.node;return a.terminals.forAll(r=>{this._intersectsObjectWithOffset(s,r,o)&&n(r)}),a.residents!==null&&a.residents.forAll(r=>{this._intersectsObjectWithOffset(s,r,o)&&n(r)}),!0})}forEach(e){z(this._root,t=>{const n=t.node;return n.terminals.forAll(e),n.residents!==null&&n.residents.forAll(e),!0}),this._degenerateObjects.forEach(e)}forEachDegenerateObject(e){this._degenerateObjects.forEach(e)}findClosest(e,t,n,o=()=>!0,s=1/0){let h=1/0,a=1/0,r=null;const u=y(e,t),m=l=>{if(--s,!o(l))return;const p=this.objectToBoundingSphere(l);if(!v(n,p))return;const O=T(e,t,f(p)),D=O-p[3],c=O+p[3];D<h&&(h=D,a=c,r=l)};return X(this._root,l=>{if(s<=0||!v(n,l.bounds)||(q(S,u,l.halfSize),k(S,S,f(l.bounds)),T(e,t,S)>a))return!1;const p=l.node;return p.terminals.forAll(O=>m(O)),p.residents!==null&&p.residents.forAll(O=>m(O)),!0},e,t),r}forEachInDepthRange(e,t,n,o,s,h,a){let r=-1/0,u=1/0;const m={setRange:c=>{n===A.DepthOrder.FRONT_TO_BACK?(r=Math.max(r,c.near),u=Math.min(u,c.far)):(r=Math.max(r,-c.far),u=Math.min(u,-c.near))}};m.setRange(o);const l=T(t,n,e),p=y(t,n),O=y(t,-n),D=c=>{if(!a(c))return;const j=this.objectToBoundingSphere(c),R=f(j),V=T(t,n,R)-l,se=V-j[3],re=V+j[3];se>u||re<r||!v(h,j)||s(c,m)};X(this._root,c=>{if(!v(h,c.bounds)||(q(S,p,c.halfSize),k(S,S,f(c.bounds)),T(t,n,S)-l>u)||(q(S,O,c.halfSize),k(S,S,f(c.bounds)),T(t,n,S)-l<r))return!1;const j=c.node;return j.terminals.forAll(R=>D(R)),j.residents!==null&&j.residents.forAll(R=>D(R)),!0},t,n)}forEachNode(e){z(this._root,t=>e(t.node,t.bounds,t.halfSize,t.depth))}forEachNeighbor(e,t){const n=$(t),o=f(t),s=r=>{const u=this.objectToBoundingSphere(r),m=$(u),l=n+m;return!(G(f(u),o)-l*l<=0)||e(r)};let h=!0;const a=r=>{h&&(h=s(r))};z(this._root,r=>{const u=$(r.bounds),m=n+u;if(G(f(r.bounds),o)-m*m>0)return!1;const l=r.node;return l.terminals.forAll(a),h&&l.residents!==null&&l.residents.forAll(a),h}),h&&this.forEachDegenerateObject(a)}_intersectsObject(e,t){const n=this.objectToBoundingSphere(t);return!(n[3]>0)||Q(n,e)}_intersectsObjectWithOffset(e,t,n){const o=this.objectToBoundingSphere(t);return!(o[3]>0)||Q(n.applyToBoundingSphere(o),e)}_add(e,t){t.advanceTo(this.objectToBoundingSphere(e))?t.node.terminals.push(e):(t.node.residents.push(e),t.node.residents.length>this._maximumObjectsPerNode&&t.depth<this._maximumDepth&&this._split(t))}_split(e){const t=e.node.residents;e.node.residents=null;for(let n=0;n<t.length;n++){const o=d.acquire().init(e);this._add(t.at(n),o),d.release(o)}}_grow(e,t){if(t!==0&&(Y(e,t,n=>this.objectToBoundingSphere(n),x),F(x[3])&&!this._fitsInsideTree(x)))if(ne(this._root.node))w(x,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize();else{const n=this._rootBoundsForRootAsSubNode(x);this._placingRootViolatesMaxDepth(n)?this._rebuildTree(x,n):this._growRootAsSubNode(n),d.release(n)}}_rebuildTree(e,t){W(f(I),f(t.bounds)),I[3]=t.halfSize,Y([e,I],2,o=>o,L);const n=d.acquire().init(this._root);this._root.initFrom(null,L,L[3]),this._root.increaseHalfSize(1.25),z(n,o=>(this.add(o.node.terminals.data,o.node.terminals.length),o.node.residents!==null&&this.add(o.node.residents.data,o.node.residents.length),!0)),d.release(n)}_placingRootViolatesMaxDepth(e){const t=Math.log(e.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return z(this._root,o=>(n=Math.max(n,o.depth),n+t<=this._maximumDepth)),n+t>this._maximumDepth}_rootBoundsForRootAsSubNode(e){const t=e[3],n=e;let o=-1/0;const s=this._root.bounds,h=this._root.halfSize;for(let r=0;r<3;r++){const u=s[r]-h-(n[r]-t),m=n[r]+t-(s[r]+h),l=Math.max(0,Math.ceil(u/(2*h))),p=Math.max(0,Math.ceil(m/(2*h)))+1,O=2**Math.ceil(Math.log(l+p)*Math.LOG2E);o=Math.max(o,O),E[r].min=l,E[r].max=p}for(let r=0;r<3;r++){let u=E[r].min,m=E[r].max;const l=(o-(u+m))/2;u+=Math.ceil(l),m+=Math.floor(l);const p=s[r]-h-u*h*2;H[r]=p+(m+u)*h}const a=o*h;return H[3]=a*ie,d.acquire().initFrom(null,H,a,0)}_growRootAsSubNode(e){const t=this._root.node;W(f(x),f(this._root.bounds)),x[3]=this._root.halfSize,this._root.init(e),e.advanceTo(x,null,!0),e.node.children=t.children,e.node.residents=t.residents,e.node.terminals=t.terminals}_shrink(){for(;;){const e=this._findShrinkIndex();if(e===-1)break;this._root.advance(e),this._root.depth=0}}_findShrinkIndex(){if(this._root.node.terminals.length!==0||this._root.isLeaf())return-1;let e=null;const t=this._root.node.children;let n=0,o=0;for(;o<t.length&&e==null;)n=o++,e=t[n];for(;o<t.length;)if(t[o++])return-1;return n}_isDegenerate(e){return!F(this.objectToBoundingSphere(e)[3])}_fitsInsideTree(e){const t=this._root.bounds,n=this._root.halfSize;return e[3]<=n&&e[0]>=t[0]-n&&e[0]<=t[0]+n&&e[1]>=t[1]-n&&e[1]<=t[1]+n&&e[2]>=t[2]-n&&e[2]<=t[2]+n}toJSON(){const{maximumDepth:e,maximumObjectsPerNode:t,_objectCount:n}=this,o=this._nodeToJSON(this._root.node);return{maximumDepth:e,maximumObjectsPerNode:t,objectCount:n,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:o}}}_nodeToJSON(e){var s,h;const t=e.children.map(a=>a?this._nodeToJSON(a):null),n=(s=e.residents)==null?void 0:s.map(a=>this.objectToBoundingSphere(a)),o=(h=e.terminals)==null?void 0:h.map(a=>this.objectToBoundingSphere(a));return{children:t,residents:n,terminals:o}}static fromJSON(e){const t=new A(n=>n,{maximumDepth:e.maximumDepth,maximumObjectsPerNode:e.maximumObjectsPerNode});return t._objectCount=e.objectCount,t._root.initFrom(e.root.node,e.root.bounds,e.root.halfSize,e.root.depth),t}}class d{constructor(){this.bounds=B(),this.halfSize=0,this.initFrom(null,null,0,0)}init(e){return this.initFrom(e.node,e.bounds,e.halfSize,e.depth)}initFrom(e,t,n,o=this.depth){return this.node=e??d.createEmptyNode(),t&&w(t,this.bounds),this.halfSize=n,this.depth=o,this}increaseHalfSize(e){this.halfSize*=e,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*ie}advance(e){let t=this.node.children[e];t||(t=d.createEmptyNode(),this.node.children[e]=t),this.node=t,this.halfSize/=2,this.depth++;const n=oe[e];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(e,t,n=!1){for(;;){if(this.isTerminalFor(e))return t&&t(this,-1),!0;if(this.isLeaf()){if(!n)return t&&t(this,-1),!1;this.node.residents=null}const o=this._childIndex(e);t&&t(this,o),this.advance(o)}}isLeaf(){return this.node.residents!=null}isTerminalFor(e){return e[3]>this.halfSize/2}_childIndex(e){const t=this.bounds;return(t[0]<e[0]?1:0)+(t[1]<e[1]?2:0)+(t[2]<e[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new C({shrink:!0}),residents:new C({shrink:!0})}}static acquire(){return d._pool.acquire()}static release(e){d._pool.release(e)}static clearPool(){d._pool.prune()}}function z(i,e){let t=d.acquire().init(i);const n=[t];for(;n.length!==0;){if(t=n.pop(),e(t)&&!t.isLeaf())for(let o=0;o<t.node.children.length;o++)t.node.children[o]&&n.push(d.acquire().init(t).advance(o));d.release(t)}}function X(i,e,t,n=A.DepthOrder.FRONT_TO_BACK){let o=d.acquire().init(i);const s=[o];for(_e(t,n,ee);s.length!==0;){if(o=s.pop(),e(o)&&!o.isLeaf())for(let h=7;h>=0;--h){const a=ee[h];o.node.children[a]&&s.push(d.acquire().init(o).advance(a))}d.release(o)}}function de(i,e,t){N.clear();const n=t.advanceTo(e,(o,s)=>{N.push(o.node),N.push(s)})?t.node.terminals:t.node.residents;if(n.removeUnordered(i),n.length===0)for(let o=N.length-2;o>=0&&le(N.data[o],N.data[o+1]);o-=2);}function le(i,e){return e>=0&&(i.children[e]=null),!!ne(i)&&(i.residents===null&&(i.residents=new C({shrink:!0})),!0)}function ue(i,e){return P(f(e.bounds),2*-e.halfSize,b),P(f(e.bounds),2*e.halfSize,g),te(i.origin,i.direction,b,g)}function ce(i,e,t){return P(f(e.bounds),2*-e.halfSize,b),P(f(e.bounds),2*e.halfSize,g),t.applyToMinMax(b,g),te(i.origin,i.direction,b,g)}function ne(i){if(i.terminals.length!==0)return!1;if(i.residents!==null)return i.residents.length===0;for(let e=0;e<i.children.length;e++)if(i.children[e])return!1;return!0}function fe(i,e){i[0]=Math.min(i[0],e[0]-e[3]),i[1]=Math.min(i[1],e[1]-e[3]),i[2]=Math.min(i[2],e[2]-e[3])}function me(i,e){i[0]=Math.max(i[0],e[0]+e[3]),i[1]=Math.max(i[1],e[1]+e[3]),i[2]=Math.max(i[2],e[2]+e[3])}function P(i,e,t){t[0]=i[0]+e,t[1]=i[1]+e,t[2]=i[2]+e}function Y(i,e,t,n){if(e===1){const o=t(i[0]);w(o,n)}else{b[0]=1/0,b[1]=1/0,b[2]=1/0,g[0]=-1/0,g[1]=-1/0,g[2]=-1/0;for(let o=0;o<e;o++){const s=t(i[o]);F(s[3])&&(fe(b,s),me(g,s))}ae(f(n),b,g,.5),n[3]=Math.max(g[0]-b[0],g[1]-b[1],g[2]-b[2])/2}}function _e(i,e,t){if(!M.length)for(let n=0;n<8;++n)M.push({index:0,distance:0});for(let n=0;n<8;++n){const o=oe[n];M.data[n].index=n,M.data[n].distance=T(i,e,o)}M.sort((n,o)=>n.distance-o.distance);for(let n=0;n<8;++n)t[n]=M.data[n].index}function y(i,e){let t,n=1/0;for(let o=0;o<8;++o){const s=T(i,e,Z[o]);s<n&&(n=s,t=Z[o])}return t}function T(i,e,t){return e*(i[0]*t[0]+i[1]*t[1]+i[2]*t[2])}function F(i){return!isNaN(i)&&i!==-1/0&&i!==1/0&&i>0}d._pool=new he(d),function(i){var e;(e=i.DepthOrder||(i.DepthOrder={}))[e.FRONT_TO_BACK=1]="FRONT_TO_BACK",e[e.BACK_TO_FRONT=-1]="BACK_TO_FRONT"}(A||(A={}));const oe=[_(-1,-1,-1),_(1,-1,-1),_(-1,1,-1),_(1,1,-1),_(-1,-1,1),_(1,-1,1),_(-1,1,1),_(1,1,1)],Z=[_(-1,-1,-1),_(-1,-1,1),_(-1,1,-1),_(-1,1,1),_(1,-1,-1),_(1,-1,1),_(1,1,-1),_(1,1,1)],ie=Math.sqrt(3),K=[null];function pe(i){return K[0]=i,K}const H=B(),S=J(),b=J(),g=J(),N=new C,be=B(),x=B(),I=B(),L=B(),E=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],M=new C,ee=[0,0,0,0,0,0,0,0],je=A;export{je as Y};

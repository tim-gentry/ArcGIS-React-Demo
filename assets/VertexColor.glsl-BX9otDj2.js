import{aa as ie,cB as Ue,d3 as ee,bp as W,cR as Ge,bk as We,mF as Te,mG as Ae,dn as Re,b4 as Je,gd as oe,mH as Ke,mI as Ye,dk as me,d0 as Le,bq as Ne}from"./index-DX0rcHuW.js";import{n as Xe,o as A}from"./interfaces-B8ge7Jg9.js";import{a as _e}from"./basicInterfaces-wONHx_SN.js";import{n as Qe,v as Ze,q as et,f as tt,b as rt,u as st}from"./Texture-0jciB86n.js";import{o as ce,h as Ie}from"./Matrix4PassUniform-CTNrzJ6Q.js";import{e as it}from"./Material-BfvzXcva.js";import{s as B}from"./Util-HYkJg9Vp.js";import{e as V}from"./VertexAttribute-BnAa5VW0.js";import{x as Be,c as Fe,y as nt,u as ot,q as at,i as Pe}from"./BufferView-XrMc2vJu.js";let Gt=class extends Qe{constructor(t){super(t),this._numLoading=0,this._disposed=!1,this._textures=t.textures,this._textureId=t.textureId,this._acquire(t.textureId,i=>this._texture=i),this._acquire(t.normalTextureId,i=>this._textureNormal=i),this._acquire(t.emissiveTextureId,i=>this._textureEmissive=i),this._acquire(t.occlusionTextureId,i=>this._textureOcclusion=i),this._acquire(t.metallicRoughnessTextureId,i=>this._textureMetallicRoughness=i)}dispose(){this._texture=ie(this._texture),this._textureNormal=ie(this._textureNormal),this._textureEmissive=ie(this._textureEmissive),this._textureOcclusion=ie(this._textureOcclusion),this._textureMetallicRoughness=ie(this._textureMetallicRoughness),this._disposed=!0}ensureResources(t){return this._numLoading===0?_e.LOADED:_e.LOADING}get textureBindParameters(){return new ct(this._texture!=null?this._texture.glTexture:null,this._textureNormal!=null?this._textureNormal.glTexture:null,this._textureEmissive!=null?this._textureEmissive.glTexture:null,this._textureOcclusion!=null?this._textureOcclusion.glTexture:null,this._textureMetallicRoughness!=null?this._textureMetallicRoughness.glTexture:null)}updateTexture(t){this._texture!=null&&t===this._texture.id||(this._texture=ie(this._texture),this._textureId=t,this._acquire(this._textureId,i=>this._texture=i))}_acquire(t,i){if(t==null)return void i(null);const r=this._textures.acquire(t);if(Ue(r))return++this._numLoading,void r.then(a=>{if(this._disposed)return ie(a),void i(null);i(a)}).finally(()=>--this._numLoading);i(r)}};class ct extends Xe{constructor(t=null,i=null,r=null,a=null,s=null,n,o){super(),this.texture=t,this.textureNormal=i,this.textureEmissive=r,this.textureOcclusion=a,this.textureMetallicRoughness=s,this.scale=n,this.normalTextureTransformMatrix=o}}function Ce(e){e.varyings.add("linearDepth","float")}function lt(e){e.vertex.uniforms.add(new et("nearFar",(t,i)=>i.camera.nearFar))}function Ve(e){e.vertex.code.add(A`float calculateLinearDepth(vec2 nearFar,float z) {
return (-z - nearFar[0]) / (nearFar[1] - nearFar[0]);
}`)}function Jt(e,t){const{vertex:i}=e;switch(t.output){case ce.Color:if(t.receiveShadows)return Ce(e),void i.code.add(A`void forwardLinearDepth() { linearDepth = gl_Position.w; }`);break;case ce.Shadow:case ce.ShadowHighlight:case ce.ShadowExcludeHighlight:case ce.ViewshedShadow:return e.include(Ze,t),Ce(e),lt(e),Ve(e),void i.code.add(A`void forwardLinearDepth() {
linearDepth = calculateLinearDepth(nearFar, vPosition_view.z);
}`)}i.code.add(A`void forwardLinearDepth() {}`)}function Kt(e){Ve(e),e.vertex.code.add(A`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = calculateLinearDepth(nearFar,eye.z);
return proj * eye;
}`),e.vertex.code.add(A`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`)}function ut(e){e.vertex.code.add(A`float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {
return absCosAngle * absCosAngle * absCosAngle;
}`),e.vertex.code.add(A`vec3 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec3 params) {
return vec3(
min(params.x / (distanceToCamera - params.y), 1.0),
screenSizePerspectiveViewAngleDependentFactor(absCosAngle),
params.z
);
}`),e.vertex.code.add(A`float applyScreenSizePerspectiveScaleFactorFloat(float size, vec3 factor) {
return mix(size * clamp(factor.x, factor.z, 1.0), size, factor.y);
}`),e.vertex.code.add(A`float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorFloat(
size,
screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params)
);
}`),e.vertex.code.add(A`vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec3 factor) {
return mix(size * clamp(factor.x, factor.z, 1.0), size, factor.y);
}`),e.vertex.code.add(A`vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));
}`)}function Yt(e){e.uniforms.add(new Ie("screenSizePerspective",t=>Ee(t.screenSizePerspective)))}function ft(e){e.uniforms.add(new Ie("screenSizePerspectiveAlignment",t=>Ee(t.screenSizePerspectiveAlignment||t.screenSizePerspective)))}function Ee(e){return ee(dt,e.parameters.divisor,e.parameters.offset,e.minScaleFactor)}const dt=W();function Xt(e,t){const i=e.vertex;t.hasVerticalOffset?(vt(i),t.hasScreenSizePerspective&&(e.include(ut),ft(i),tt(e.vertex,t)),i.code.add(A`
      vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);
        ${t.spherical?A`vec3 worldNormal = normalize(worldPos + localOrigin);`:A`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}
        ${t.hasScreenSizePerspective?A`
            float cosAngle = dot(worldNormal, normalize(worldPos - cameraPosition));
            float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);`:A`
            float verticalOffsetScreenHeight = verticalOffset.x;`}
        // Screen sized offset in world space, used for example for line callouts
        float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);
        return worldNormal * worldOffset;
      }

      vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        return worldPos + calculateVerticalOffset(worldPos, localOrigin);
      }
    `)):i.code.add(A`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`)}const ht=We();function vt(e){e.uniforms.add(new rt("verticalOffset",(t,i)=>{const{minWorldLength:r,maxWorldLength:a,screenLength:s}=t.verticalOffset,n=Math.tan(.5*i.camera.fovY)/(.5*i.camera.fullViewport[3]),o=i.camera.pixelRatio||1;return Ge(ht,s*o,n,r,a)}))}function Qt(e,t,i,r=1){const{data:a,indices:s}=e,n=t.typedBuffer,o=t.typedBufferStride,c=s.length;if(i*=o,r===1)for(let u=0;u<c;++u)n[i]=a[s[u]],i+=o;else for(let u=0;u<c;++u){const l=a[s[u]];for(let f=0;f<r;f++)n[i]=l,i+=o}}function Me(e,t,i){const{data:r,indices:a}=e,s=t.typedBuffer,n=t.typedBufferStride,o=a.length;i*=n;for(let c=0;c<o;++c){const u=2*a[c];s[i]=r[u],s[i+1]=r[u+1],i+=n}}function qe(e,t,i,r){const{data:a,indices:s}=e,n=t.typedBuffer,o=t.typedBufferStride,c=s.length;if(i*=o,r==null||r===1)for(let u=0;u<c;++u){const l=3*s[u];n[i]=a[l],n[i+1]=a[l+1],n[i+2]=a[l+2],i+=o}else for(let u=0;u<c;++u){const l=3*s[u];for(let f=0;f<r;++f)n[i]=a[l],n[i+1]=a[l+1],n[i+2]=a[l+2],i+=o}}function De(e,t,i,r=1){const{data:a,indices:s}=e,n=t.typedBuffer,o=t.typedBufferStride,c=s.length;if(i*=o,r===1)for(let u=0;u<c;++u){const l=4*s[u];n[i]=a[l],n[i+1]=a[l+1],n[i+2]=a[l+2],n[i+3]=a[l+3],i+=o}else for(let u=0;u<c;++u){const l=4*s[u];for(let f=0;f<r;++f)n[i]=a[l],n[i+1]=a[l+1],n[i+2]=a[l+2],n[i+3]=a[l+3],i+=o}}function Zt(e,t,i){const r=e.typedBuffer,a=e.typedBufferStride;t*=a;for(let s=0;s<i;++s)r[t]=0,r[t+1]=0,r[t+2]=0,r[t+3]=0,t+=a}function pt(e,t,i,r,a=1){if(!t)return void qe(e,i,r,a);const{data:s,indices:n}=e,o=i.typedBuffer,c=i.typedBufferStride,u=n.length,l=t[0],f=t[1],w=t[2],I=t[4],M=t[5],R=t[6],S=t[8],L=t[9],_=t[10],F=t[12],P=t[13],y=t[14];r*=c;let O=0,v=0,h=0;const g=Te(t)?m=>{O=s[m]+F,v=s[m+1]+P,h=s[m+2]+y}:m=>{const d=s[m],x=s[m+1],p=s[m+2];O=l*d+I*x+S*p+F,v=f*d+M*x+L*p+P,h=w*d+R*x+_*p+y};if(a===1)for(let m=0;m<u;++m)g(3*n[m]),o[r]=O,o[r+1]=v,o[r+2]=h,r+=c;else for(let m=0;m<u;++m){g(3*n[m]);for(let d=0;d<a;++d)o[r]=O,o[r+1]=v,o[r+2]=h,r+=c}}function mt(e,t,i,r,a=1){if(!t)return void qe(e,i,r,a);const{data:s,indices:n}=e,o=t,c=i.typedBuffer,u=i.typedBufferStride,l=n.length,f=o[0],w=o[1],I=o[2],M=o[4],R=o[5],S=o[6],L=o[8],_=o[9],F=o[10],P=!Ae(o),y=1e-6,O=1-y;r*=u;let v=0,h=0,g=0;const m=Te(o)?d=>{v=s[d],h=s[d+1],g=s[d+2]}:d=>{const x=s[d],p=s[d+1],z=s[d+2];v=f*x+M*p+L*z,h=w*x+R*p+_*z,g=I*x+S*p+F*z};if(a===1)if(P)for(let d=0;d<l;++d){m(3*n[d]);const x=v*v+h*h+g*g;if(x<O&&x>y){const p=1/Math.sqrt(x);c[r]=v*p,c[r+1]=h*p,c[r+2]=g*p}else c[r]=v,c[r+1]=h,c[r+2]=g;r+=u}else for(let d=0;d<l;++d)m(3*n[d]),c[r]=v,c[r+1]=h,c[r+2]=g,r+=u;else for(let d=0;d<l;++d){if(m(3*n[d]),P){const x=v*v+h*h+g*g;if(x<O&&x>y){const p=1/Math.sqrt(x);v*=p,h*=p,g*=p}}for(let x=0;x<a;++x)c[r]=v,c[r+1]=h,c[r+2]=g,r+=u}}function xt(e,t,i,r,a=1){if(!t)return void De(e,i,r,a);const{data:s,indices:n}=e,o=t,c=i.typedBuffer,u=i.typedBufferStride,l=n.length,f=o[0],w=o[1],I=o[2],M=o[4],R=o[5],S=o[6],L=o[8],_=o[9],F=o[10],P=!Ae(o),y=1e-6,O=1-y;if(r*=u,a===1)for(let v=0;v<l;++v){const h=4*n[v],g=s[h],m=s[h+1],d=s[h+2],x=s[h+3];let p=f*g+M*m+L*d,z=w*g+R*m+_*d,b=I*g+S*m+F*d;if(P){const $=p*p+z*z+b*b;if($<O&&$>y){const C=1/Math.sqrt($);p*=C,z*=C,b*=C}}c[r]=p,c[r+1]=z,c[r+2]=b,c[r+3]=x,r+=u}else for(let v=0;v<l;++v){const h=4*n[v],g=s[h],m=s[h+1],d=s[h+2],x=s[h+3];let p=f*g+M*m+L*d,z=w*g+R*m+_*d,b=I*g+S*m+F*d;if(P){const $=p*p+z*z+b*b;if($<O&&$>y){const C=1/Math.sqrt($);p*=C,z*=C,b*=C}}for(let $=0;$<a;++$)c[r]=p,c[r+1]=z,c[r+2]=b,c[r+3]=x,r+=u}}function gt(e,t,i,r,a=1){const{data:s,indices:n}=e,o=i.typedBuffer,c=i.typedBufferStride,u=n.length;if(r*=c,t!==s.length||t!==4)if(a!==1)if(t!==4)for(let l=0;l<u;++l){const f=3*n[l];for(let w=0;w<a;++w)o[r]=s[f],o[r+1]=s[f+1],o[r+2]=s[f+2],o[r+3]=255,r+=c}else for(let l=0;l<u;++l){const f=4*n[l];for(let w=0;w<a;++w)o[r]=s[f],o[r+1]=s[f+1],o[r+2]=s[f+2],o[r+3]=s[f+3],r+=c}else{if(t===4){for(let l=0;l<u;++l){const f=4*n[l];o[r]=s[f],o[r+1]=s[f+1],o[r+2]=s[f+2],o[r+3]=s[f+3],r+=c}return}for(let l=0;l<u;++l){const f=3*n[l];o[r]=s[f],o[r+1]=s[f+1],o[r+2]=s[f+2],o[r+3]=255,r+=c}}else{o[r]=s[0],o[r+1]=s[1],o[r+2]=s[2],o[r+3]=s[3];const l=new Uint32Array(i.typedBuffer.buffer,i.start),f=c/4,w=l[r/=4];r+=f;const I=u*a;for(let M=1;M<I;++M)l[r]=w,r+=f}}function St(e,t,i){const{data:r,indices:a}=e,s=t.typedBuffer,n=t.typedBufferStride,o=a.length,c=r[0];i*=n;for(let u=0;u<o;++u)s[i]=c,i+=n}function wt(e,t,i,r,a=1){const s=t.typedBuffer,n=t.typedBufferStride;if(r*=n,a===1)for(let o=0;o<i;++o)s[r]=e[0],s[r+1]=e[1],s[r+2]=e[2],s[r+3]=e[3],r+=n;else for(let o=0;o<i;++o)for(let c=0;c<a;++c)s[r]=e[0],s[r+1]=e[1],s[r+2]=e[2],s[r+3]=e[3],r+=n}function zt(e,t,i,r,a,s){var n;for(const o of t.fields.keys()){const c=e.attributes.get(o),u=c==null?void 0:c.indices;if(c&&u)Ot(o,c,i,r,a,s);else if(o===V.OBJECTANDLAYERIDCOLOR&&e.objectAndLayerIdColor!=null){const l=(n=e.attributes.get(V.POSITION))==null?void 0:n.indices;if(l){const f=l.length,w=a.getField(o,Be);wt(e.objectAndLayerIdColor,w,f,s)}}}}function Ot(e,t,i,r,a,s){switch(e){case V.POSITION:{B(t.size===3);const n=a.getField(e,Pe);B(!!n,`No buffer view for ${e}`),n&&pt(t,i,n,s);break}case V.NORMAL:{B(t.size===3);const n=a.getField(e,Pe);B(!!n,`No buffer view for ${e}`),n&&mt(t,r,n,s);break}case V.NORMALCOMPRESSED:{B(t.size===2);const n=a.getField(e,at);B(!!n,`No buffer view for ${e}`),n&&Me(t,n,s);break}case V.UV0:{B(t.size===2);const n=a.getField(e,ot);B(!!n,`No buffer view for ${e}`),n&&Me(t,n,s);break}case V.COLOR:case V.SYMBOLCOLOR:{const n=a.getField(e,Be);B(!!n,`No buffer view for ${e}`),B(t.size===3||t.size===4),!n||t.size!==3&&t.size!==4||gt(t,t.size,n,s);break}case V.COLORFEATUREATTRIBUTE:{const n=a.getField(e,nt);B(!!n,`No buffer view for ${e}`),B(t.size===1),n&&t.size===1&&St(t,n,s);break}case V.TANGENT:{B(t.size===4);const n=a.getField(e,Fe);B(!!n,`No buffer view for ${e}`),n&&xt(t,i,n,s);break}case V.PROFILERIGHT:case V.PROFILEUP:case V.PROFILEVERTEXANDNORMAL:case V.FEATUREVALUE:{B(t.size===4);const n=a.getField(e,Fe);B(!!n,`No buffer view for ${e}`),n&&De(t,n,s)}}}const bt=Re(1,1,0,1),$t=Re(1,0,1,1);function er(e){e.fragment.uniforms.add(new st("depthTexture",(t,i)=>i.mainDepth)),e.fragment.constants.add("occludedHighlightFlag","vec4",bt).add("unoccludedHighlightFlag","vec4",$t),e.fragment.code.add(A`void outputHighlight() {
float sceneDepth = float(texelFetch(depthTexture, ivec2(gl_FragCoord.xy), 0).x);
if (gl_FragCoord.z > sceneDepth + 5e-7) {
fragColor = occludedHighlightFlag;
} else {
fragColor = unoccludedHighlightFlag;
}
}`)}class yt{constructor(t=!1,i=!0){this.isVerticalRay=t,this.normalRequired=i}}const ue=Je();function tr(e,t,i,r,a,s){if(!e.visible)return;const n=oe(je,r,i),o=(u,l,f)=>{s(u,f,l,!1)},c=new yt(!1,t.options.normalRequired);if(e.boundingInfo){B(e.type===it.Mesh);const u=t.tolerance;ke(e.boundingInfo,i,n,u,a,c,o)}else{const u=e.attributes.get(V.POSITION),l=u.indices;He(i,n,0,l.length/3,l,u.data,u.stride,a,c,o)}}const _t=W();function ke(e,t,i,r,a,s,n){if(e==null)return;const o=At(i,_t);if(Ke(ue,e.bbMin),Ye(ue,e.bbMax),a!=null&&a.applyToAabb(ue),Rt(ue,t,o,r)){const{primitiveIndices:c,position:u}=e,l=c?c.length:u.indices.length/3;if(l>Nt){const f=e.getChildren();if(f!==void 0){for(const w of f)ke(w,t,i,r,a,s,n);return}}Ft(t,i,0,l,u.indices,u.data,u.stride,c,a,s,n)}}const ne=W();function rr(e,t,i,r,a,s,n,o,c){const{data:u,stride:l}=s;He(e,oe(je,t,e),i,r,a,u,l,n,o,c)}function sr(e,t,i,r,a,s,n,o,c,u=null,l=0){const f=e[0],w=e[1],I=e[2],M=t[0],R=t[1],S=t[2];for(let L=i;L<r;++L){const _=l+(u?u[L]:L),F=3*_,P=n*a[F],y=s[P],O=s[P+1],v=s[P+2],h=n*a[F+1],g=s[h],m=s[h+1],d=s[h+2],x=n*a[F+2],p=g-y,z=m-O,b=d-v,$=s[x]-y,C=s[x+1]-O,E=s[x+2]-v,H=R*E-C*S,j=S*$-E*M,U=M*C-$*R,T=p*H+z*j+b*U;if(Math.abs(T)<=ge)continue;const D=f-y,k=w-O,G=I-v,N=D*H+k*j+G*U;if(T>0){if(N<0||N>T)continue}else if(N>0||N<T)continue;const J=k*b-z*G,K=G*p-b*D,Y=D*z-p*k,q=M*J+R*K+S*Y;if(T>0){if(q<0||N+q>T)continue}else if(q>0||N+q<T)continue;const X=($*J+C*K+E*Y)/T;X>=0&&c(X,_,o?xe(p,z,b,$,C,E,ne):null)}}function ir(e,t,i,r,a,s,n,o,c,u,l,f=null,w=0){const I=e[0],M=e[1],R=e[2],S=t[0],L=t[1],_=t[2];for(let F=i;F<r;++F){const P=w+(f?f[F]:F),y=3*P,O=n*a[y],v=s[O],h=s[O+1],g=s[O+2],m=n*a[y+1],d=s[m],x=s[m+1],p=s[m+2],z=n*a[y+2],b=s[z],$=s[z+1],C=s[z+2],E=g-c,H=o/Math.sqrt(v*v+h*h+E*E),j=v+v*H,U=h+h*H,T=g+E*H,D=p-c,k=o/Math.sqrt(d*d+x*x+D*D),G=d+d*k,N=x+x*k,J=p+D*k,K=C-c,Y=o/Math.sqrt(b*b+$*$+K*K),q=G-j,X=N-U,te=J-T,re=b+b*Y-j,Q=$+$*Y-U,se=C+K*Y-T,Se=L*se-Q*_,we=_*re-se*S,ze=S*Q-re*L,Z=q*Se+X*we+te*ze;if(Math.abs(Z)<=ge)continue;const he=I-j,ve=M-U,pe=R-T,ae=he*Se+ve*we+pe*ze;if(Z>0){if(ae<0||ae>Z)continue}else if(ae>0||ae<Z)continue;const Oe=ve*te-X*pe,be=pe*q-te*he,$e=he*X-q*ve,le=S*Oe+L*be+_*$e;if(Z>0){if(le<0||ae+le>Z)continue}else if(le>0||ae+le<Z)continue;const ye=(re*Oe+Q*be+se*$e)/Z;ye>=0&&l(ye,P,u?xe(q,X,te,re,Q,se,ne):null)}}function Ft(e,t,i,r,a,s,n,o,c,u,l){const f=e[0],w=e[1],I=e[2],M=t[0],R=t[1],S=t[2],{normalRequired:L}=u;for(let _=i;_<r;++_){const F=o[_],P=3*F,y=n*a[P];let O=s[y],v=s[y+1],h=s[y+2];const g=n*a[P+1];let m=s[g],d=s[g+1],x=s[g+2];const p=n*a[P+2];let z=s[p],b=s[p+1],$=s[p+2];c!=null&&([O,v,h]=c.applyToVertex(O,v,h,_),[m,d,x]=c.applyToVertex(m,d,x,_),[z,b,$]=c.applyToVertex(z,b,$,_));const C=m-O,E=d-v,H=x-h,j=z-O,U=b-v,T=$-h,D=R*T-U*S,k=S*j-T*M,G=M*U-j*R,N=C*D+E*k+H*G;if(Math.abs(N)<=ge)continue;const J=f-O,K=w-v,Y=I-h,q=J*D+K*k+Y*G;if(N>0){if(q<0||q>N)continue}else if(q>0||q<N)continue;const X=K*H-E*Y,te=Y*C-H*J,re=J*E-C*K,Q=M*X+R*te+S*re;if(N>0){if(Q<0||q+Q>N)continue}else if(Q>0||q+Q<N)continue;const se=(j*X+U*te+T*re)/N;se>=0&&l(se,F,L?xe(C,E,H,j,U,T,ne):null)}}function He(e,t,i,r,a,s,n,o,c,u){const l=t,f=It,w=Math.abs(l[0]),I=Math.abs(l[1]),M=Math.abs(l[2]),R=w>=I?w>=M?0:2:I>=M?1:2,S=R,L=l[S]<0?2:1,_=(R+L)%3,F=(R+(3-L))%3,P=l[_]/l[S],y=l[F]/l[S],O=1/l[S],v=Pt,h=Ct,g=Mt,{normalRequired:m}=c;for(let d=i;d<r;++d){const x=3*d,p=n*a[x];ee(f[0],s[p+0],s[p+1],s[p+2]);const z=n*a[x+1];ee(f[1],s[z+0],s[z+1],s[z+2]);const b=n*a[x+2];ee(f[2],s[b+0],s[b+1],s[b+2]),o&&(me(f[0],o.applyToVertex(f[0][0],f[0][1],f[0][2],d)),me(f[1],o.applyToVertex(f[1][0],f[1][1],f[1][2],d)),me(f[2],o.applyToVertex(f[2][0],f[2][1],f[2][2],d))),oe(v,f[0],e),oe(h,f[1],e),oe(g,f[2],e);const $=v[_]-P*v[S],C=v[F]-y*v[S],E=h[_]-P*h[S],H=h[F]-y*h[S],j=g[_]-P*g[S],U=g[F]-y*g[S],T=j*H-U*E,D=$*U-C*j,k=E*C-H*$;if((T<0||D<0||k<0)&&(T>0||D>0||k>0))continue;const G=T+D+k;if(G===0)continue;const N=T*(O*v[S])+D*(O*h[S])+k*(O*g[S]);if(N*Math.sign(G)<0)continue;const J=N/G;J>=0&&u(J,d,m?Tt(f):null)}}const Pt=W(),Ct=W(),Mt=W();function xe(e,t,i,r,a,s,n){return ee(fe,e,t,i),ee(de,r,a,s),Le(n,fe,de),Ne(n,n),n}function Tt(e){return oe(fe,e[1],e[0]),oe(de,e[2],e[0]),Le(ne,fe,de),Ne(ne,ne),ne}const fe=W(),de=W();function nr(e,t,i){return ee(i,1/(t[0]-e[0]),1/(t[1]-e[1]),1/(t[2]-e[2]))}function At(e,t){return ee(t,1/e[0],1/e[1],1/e[2])}function Rt(e,t,i,r){return Lt(e,t,i,r,1/0)}function Lt(e,t,i,r,a){const s=(e[0]-r-t[0])*i[0],n=(e[3]+r-t[0])*i[0];let o=Math.min(s,n),c=Math.max(s,n);const u=(e[1]-r-t[1])*i[1],l=(e[4]+r-t[1])*i[1];if(c=Math.min(c,Math.max(u,l)),c<0||(o=Math.max(o,Math.min(u,l)),o>c))return!1;const f=(e[2]-r-t[2])*i[2],w=(e[5]+r-t[2])*i[2];return c=Math.min(c,Math.max(f,w)),!(c<0)&&(o=Math.max(o,Math.min(f,w)),!(o>c)&&o<a)}const Nt=1e3,ge=1e-7,je=W(),It=[W(),W(),W()];class or{constructor(t){this.vertexBufferLayout=t}elementCount(t){return t.attributes.get(V.POSITION).indices.length}write(t,i,r,a,s){zt(r,this.vertexBufferLayout,t,i,a,s)}}function ar(e,t){t.hasVertexColors?(e.attributes.add(V.COLOR,"vec4"),e.varyings.add("vColor","vec4"),e.vertex.code.add(A`void forwardVertexColor() { vColor = color; }`),e.vertex.code.add(A`void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }`)):e.vertex.code.add(A`void forwardVertexColor() {}
void forwardNormalizedVertexColor() {}`)}export{Ot as A,ir as B,nr as C,zt as E,mt as O,wt as R,gt as S,er as a,pt as b,Xt as c,Qt as d,ar as e,vt as f,ft as g,bt as h,lt as i,$t as j,De as k,ct as l,yt as m,Jt as n,Kt as o,tr as p,Rt as q,or as r,ut as s,Yt as t,Gt as u,Ce as v,Lt as w,rr as x,Zt as y,sr as z};

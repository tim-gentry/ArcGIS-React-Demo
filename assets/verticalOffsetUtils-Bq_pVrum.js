import{y as P}from"./mat3-Ck4GO2qT.js";import{e as U}from"./mat3f64-BBpwCtoL.js";import{bp as c,d7 as p,d3 as O,dV as u,bC as k,by as X,dQ as D,dW as E,bw as Y,d5 as Z}from"./index-DX0rcHuW.js";import{e as v}from"./mat4f64-Dk4dwAN8.js";import{_ as K,V as _}from"./sphere-COyqsaGw.js";import{l as tt}from"./ViewingMode-Dodu7ZZk.js";import{I as st,L as rt}from"./orientedBoundingBox-BTwqkknQ.js";class Mt{constructor(){this._transform=v(),this._transformInverse=new T({value:this._transform},X,v),this._transformInverseTranspose=new T(this._transformInverse,D,v),this._transformTranspose=new T({value:this._transform},D,v),this._transformInverseRotation=new T({value:this._transform},P,U)}_invalidateLazyTransforms(){this._transformInverse.invalidate(),this._transformInverseTranspose.invalidate(),this._transformTranspose.invalidate(),this._transformInverseRotation.invalidate()}get transform(){return this._transform}get inverse(){return this._transformInverse.value}get inverseTranspose(){return this._transformInverseTranspose.value}get inverseRotation(){return this._transformInverseRotation.value}get transpose(){return this._transformTranspose.value}setTransformMatrix(t){E(this._transform,t)}multiplyTransform(t){Y(this._transform,this._transform,t)}set(t){E(this._transform,t),this._invalidateLazyTransforms()}setAndInvalidateLazyTransforms(t,r){this.setTransformMatrix(t),this.multiplyTransform(r),this._invalidateLazyTransforms()}}class T{constructor(t,r,e){this._original=t,this._update=r,this._dirty=!0,this._transform=e()}invalidate(){this._dirty=!0}get value(){return this._dirty&&(this._update(this._transform,this._original.value),this._dirty=!1),this._transform}}class et{constructor(t=0){this.offset=t,this.tmpVertex=c()}applyToVertex(t,r,e){const i=O(I,t,r,e),o=Z(N,i,this.localOrigin),a=this.offset/p(o);return u(this.tmpVertex,i,o,a),this.tmpVertex}applyToAabb(t){const r=at,e=ot,i=ht;for(let s=0;s<3;++s)r[s]=t[0+s]+this.localOrigin[s],e[s]=t[3+s]+this.localOrigin[s],i[s]=r[s];const o=this.applyToVertex(r[0],r[1],r[2]);for(let s=0;s<3;++s)t[s]=o[s],t[s+3]=o[s];const a=s=>{const n=this.applyToVertex(s[0],s[1],s[2]);for(let l=0;l<3;++l)t[l]=Math.min(t[l],n[l]),t[l+3]=Math.max(t[l+3],n[l])};for(let s=1;s<8;++s){for(let n=0;n<3;++n)i[n]=s&1<<n?e[n]:r[n];a(i)}let f=0;for(let s=0;s<3;++s)r[s]*e[s]<0&&(f|=1<<s);if(f!==0&&f!==7){for(let s=0;s<8;++s)if(!(f&s)){for(let n=0;n<3;++n)i[n]=f&1<<n?0:s&1<<n?r[n]:e[n];a(i)}}for(let s=0;s<3;++s)t[s]-=this.localOrigin[s],t[s+3]-=this.localOrigin[s];return t}}class nt{constructor(t=0){this.componentLocalOriginLength=0,this._totalOffset=0,this._offset=0,this._tmpVertex=c(),this._tmpMbs=K(),this._tmpObb=new st,this._resetOffset(t)}_resetOffset(t){this._offset=t,this._totalOffset=t}set offset(t){this._resetOffset(t)}get offset(){return this._offset}set componentOffset(t){this._totalOffset=this._offset+t}set localOrigin(t){this.componentLocalOriginLength=p(t)}applyToVertex(t,r,e){const i=O(I,t,r,e),o=O(N,t,r,e+this.componentLocalOriginLength),a=this._totalOffset/p(o);return u(this._tmpVertex,i,o,a),this._tmpVertex}applyToAabb(t){const r=this.componentLocalOriginLength,e=t[0],i=t[1],o=t[2]+r,a=t[3],f=t[4],s=t[5]+r,n=Math.abs(e),l=Math.abs(i),y=Math.abs(o),d=Math.abs(a),x=Math.abs(f),V=Math.abs(s),w=.5*(1+Math.sign(e*a))*Math.min(n,d),$=.5*(1+Math.sign(i*f))*Math.min(l,x),q=.5*(1+Math.sign(o*s))*Math.min(y,V),z=Math.max(n,d),A=Math.max(l,x),R=Math.max(y,V),j=Math.sqrt(w*w+$*$+q*q),B=Math.sign(n+e),C=Math.sign(l+i),G=Math.sign(y+o),Q=Math.sign(d+a),S=Math.sign(x+f),W=Math.sign(V+s),m=this._totalOffset;if(j<m)return t[0]-=(1-B)*m,t[1]-=(1-C)*m,t[2]-=(1-G)*m,t[3]+=Q*m,t[4]+=S*m,t[5]+=W*m,t;const M=m/Math.sqrt(z*z+A*A+R*R),b=m/j,g=b-M,L=-g;return t[0]+=e*(B*L+b),t[1]+=i*(C*L+b),t[2]+=o*(G*L+b),t[3]+=a*(Q*g+M),t[4]+=f*(S*g+M),t[5]+=s*(W*g+M),t}applyToMbs(t){const r=p(_(t)),e=this._totalOffset/r;return u(_(this._tmpMbs),_(t),_(t),e),this._tmpMbs[3]=t[3]+t[3]*this._totalOffset/r,this._tmpMbs}applyToObb(t){return rt(t,this._totalOffset,this._totalOffset,tt.Global,this._tmpObb),this._tmpObb}}class it{constructor(t=0){this.offset=t,this.sphere=K(),this.tmpVertex=c()}applyToVertex(t,r,e){const i=this.objectTransform.transform,o=O(I,t,r,e),a=k(o,o,i),f=this.offset/p(a);u(a,a,a,f);const s=this.objectTransform.inverse;return k(this.tmpVertex,a,s),this.tmpVertex}applyToMinMax(t,r){const e=this.offset/p(t);u(t,t,t,e);const i=this.offset/p(r);u(r,r,r,i)}applyToAabb(t){const r=this.offset/Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]+=t[0]*r,t[1]+=t[1]*r,t[2]+=t[2]*r;const e=this.offset/Math.sqrt(t[3]*t[3]+t[4]*t[4]+t[5]*t[5]);return t[3]+=t[3]*e,t[4]+=t[4]*e,t[5]+=t[5]*e,t}applyToBoundingSphere(t){const r=p(_(t)),e=this.offset/r;return u(_(this.sphere),_(t),_(t),e),this.sphere[3]=t[3]+t[3]*this.offset/r,this.sphere}}const F=new it;function bt(h){return h!=null?(F.offset=h,F):null}const H=new nt;function gt(h){return h!=null?(H.offset=h,H):null}const J=new et;function vt(h){return h!=null?(J.offset=h,J):null}const Tt="terrain",I=c(),N=c(),at=c(),ot=c(),ht=c();export{vt as I,gt as L,bt as d,Mt as v,Tt as w};

import{aN as G,c2 as Q,ac as R,ad as q,ag as H,bh as J,dI as U,b8 as W,fe as ee}from"./index-DX0rcHuW.js";import{e as Y}from"./TileKey-m4M152GY.js";import{m as te,b as K}from"./vec2-C-4tM9Uv.js";import{_ as se}from"./QueueProcessor-01Ee2ByR.js";function M(h,e){return[h,e]}function B(h,e,t){return h[0]=e,h[1]=t,h}function ie(h,e,t,s,i){return h[0]=e,h[1]=t,h[2]=s,h[3]=i,h}const T=new Y("0/0/0/0");let oe=class Z{static create(e,t,s=null){const i=G(e.spatialReference),o=t.origin||M(e.origin.x,e.origin.y),a=M(e.size[0]*t.resolution,e.size[1]*t.resolution),l=M(-1/0,-1/0),c=M(1/0,1/0),r=M(1/0,1/0);s!=null&&(B(l,Math.max(0,Math.floor((s.xmin-o[0])/a[0])),Math.max(0,Math.floor((o[1]-s.ymax)/a[1]))),B(c,Math.max(0,Math.floor((s.xmax-o[0])/a[0])),Math.max(0,Math.floor((o[1]-s.ymin)/a[1]))),B(r,c[0]-l[0]+1,c[1]-l[1]+1));const{cols:n,rows:u}=t;let d,_,w,m;return!s&&n&&u&&(B(l,n[0],u[0]),B(c,n[1],u[1]),B(r,n[1]-n[0]+1,u[1]-u[0]+1)),e.isWrappable?(d=M(Math.ceil(Math.round((i.valid[1]-i.valid[0])/t.resolution)/e.size[0]),r[1]),_=M(Math.floor((i.origin[0]-o[0])/a[0]),l[1]),w=M(d[0]+_[0]-1,c[1]),m=!0):(_=l,w=c,d=r,m=!1),new Z(t.level,t.resolution,t.scale,o,l,c,r,a,_,w,d,m)}constructor(e,t,s,i,o,a,l,c,r,n,u,d){this.level=e,this.resolution=t,this.scale=s,this.origin=i,this.first=o,this.last=a,this.size=l,this.norm=c,this.worldStart=r,this.worldEnd=n,this.worldSize=u,this.wrap=d}normalizeCol(e){if(!this.wrap)return e;const t=this.worldSize[0];return e<0?t-1-Math.abs((e+1)%t):e%t}denormalizeCol(e,t){return this.wrap?this.worldSize[0]*t+e:e}getWorldForColumn(e){return this.wrap?Math.floor(e/this.worldSize[0]):0}getFirstColumnForWorld(e){return e*this.worldSize[0]+this.first[0]}getLastColumnForWorld(e){return e*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(e){return(e-this.origin[0])/this.norm[0]}getXForColumn(e){return this.origin[0]+e*this.norm[0]}getRowForY(e){return(this.origin[1]-e)/this.norm[1]}getYForRow(e){return this.origin[1]-e*this.norm[1]}getTileBounds(e,t,s=!1){T.set(t);const i=s?T.col:this.denormalizeCol(T.col,T.world),o=T.row;return ie(e,this.getXForColumn(i),this.getYForRow(o+1),this.getXForColumn(i+1),this.getYForRow(o)),e}getTileCoords(e,t,s=!1){T.set(t);const i=s?T.col:this.denormalizeCol(T.col,T.world);return Array.isArray(e)?B(e,this.getXForColumn(i),this.getYForRow(T.row)):(e.x=this.getXForColumn(i),e.y=this.getYForRow(T.row)),e}};class A{constructor(){this.spans=[]}acquire(e){this.lodInfo=e}release(){this.lodInfo=null,this.spans.length=0}*keys(){const e=this.lodInfo;for(const{row:t,colFrom:s,colTo:i}of this.spans)for(let o=s;o<=i;o++){const a=e.getWorldForColumn(o);yield new Y(e.level,t,e.normalizeCol(o),a)}}forEach(e,t){const{spans:s,lodInfo:i}=this,{level:o}=i;if(s.length!==0)for(const{row:a,colFrom:l,colTo:c}of s)for(let r=l;r<=c;r++)e.call(t,o,a,i.normalizeCol(r),i.getWorldForColumn(r))}}A.pool=new Q(A);let N=class{constructor(e,t,s){this.row=e,this.colFrom=t,this.colTo=s}};const g=new Y("0/0/0/0");class X{static create(e,t){e[1]>t[1]&&([e,t]=[t,e]);const[s,i]=e,[o,a]=t,l=o-s,c=a-i,r=c!==0?l/c:0,n=(Math.ceil(i)-i)*r,u=(Math.floor(i)-i)*r;return new X(s,Math.floor(i),Math.ceil(a),r,l<0?n:u,l<0?u:n,l<0?o:s,l<0?s:o)}constructor(e,t,s,i,o,a,l,c){this.x=e,this.ymin=t,this.ymax=s,this.invM=i,this.leftAdjust=o,this.rightAdjust=a,this.leftBound=l,this.rightBound=c}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const v=[[0,0],[0,0],[0,0],[0,0]],le=1e-6;let de=class{constructor(e,t=null,s=e.lods[0].level,i=e.lods[e.lods.length-1].level){this.tileInfo=e,this.fullExtent=t,this.scales=[],this._infoByScale={},this._infoByLevel={};const o=e.lods.filter(l=>l.level>=s&&l.level<=i);this.minScale=o[0].scale,this.maxScale=o[o.length-1].scale;const a=this._lodInfos=o.map(l=>oe.create(e,l,t));o.forEach((l,c)=>{this._infoByLevel[l.level]=a[c],this._infoByScale[l.scale]=a[c],this.scales[c]=l.scale},this),this._wrap=e.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(e){return this._infoByLevel[typeof e=="number"?e:e.level]}getTileBounds(e,t,s=!1){g.set(t);const i=this._infoByLevel[g.level];return i?i.getTileBounds(e,g,s):e}getTileCoords(e,t,s=!1){g.set(t);const i=this._infoByLevel[g.level];return i?i.getTileCoords(e,g,s):e}getTileCoverage(e,t=192,s=!0,i="closest"){if(!s&&(e.scale>this.minScale||e.scale<this.maxScale))return null;const o=i==="closest"?this.getClosestInfoForScale(e.scale):this.getSmallestInfoForScale(e.scale),a=A.pool.acquire(o),l=this._wrap;let c,r,n,u=1/0,d=-1/0;const _=a.spans;v[0][0]=v[0][1]=v[1][1]=v[3][0]=-t,v[1][0]=v[2][0]=e.size[0]+t,v[2][1]=v[3][1]=e.size[1]+t;for(const f of v)e.toMap(f,f),f[0]=o.getColumnForX(f[0]),f[1]=o.getRowForY(f[1]);const w=[];let m=3;for(let f=0;f<4;f++){if(v[f][1]===v[m][1]){m=f;continue}const y=X.create(v[f],v[m]);u=Math.min(y.ymin,u),d=Math.max(y.ymax,d),w[y.ymin]===void 0&&(w[y.ymin]=[]),w[y.ymin].push(y),m=f}if(u==null||d==null||d-u>100)return null;let I=[];for(c=u;c<d;){w[c]!=null&&(I=I.concat(w[c])),r=1/0,n=-1/0;for(let f=I.length-1;f>=0;f--){const y=I[f];r=Math.min(r,y.getLeftCol()),n=Math.max(n,y.getRightCol())}if(r=Math.floor(r),n=Math.floor(n),c>=o.first[1]&&c<=o.last[1])if(l)if(o.size[0]<o.worldSize[0]){const f=Math.floor(n/o.worldSize[0]);for(let y=Math.floor(r/o.worldSize[0]);y<=f;y++)_.push(new N(c,Math.max(o.getFirstColumnForWorld(y),r),Math.min(o.getLastColumnForWorld(y),n)))}else _.push(new N(c,r,n));else r>o.last[0]||n<o.first[0]||(r=Math.max(r,o.first[0]),n=Math.min(n,o.last[0]),_.push(new N(c,r,n)));c+=1;for(let f=I.length-1;f>=0;f--){const y=I[f];y.ymax>=c?y.incrRow():I.splice(f,1)}}return a}getTileParentId(e){g.set(e);const t=this._infoByLevel[g.level],s=this._lodInfos.indexOf(t)-1;return s<0?null:(this._getTileIdAtLOD(g,this._lodInfos[s],g),g.id)}getTileResolution(e){const t=this._infoByLevel[typeof e=="object"?e.level:e];return t?t.resolution:-1}getTileScale(e){const t=this._infoByLevel[e.level];return t?t.scale:-1}intersects(e,t){g.set(t);const s=this._infoByLevel[g.level],i=e.lodInfo;if(i.resolution>s.resolution){this._getTileIdAtLOD(g,i,g);const a=i.denormalizeCol(g.col,g.world);for(const l of e.spans)if(l.row===g.row&&l.colFrom<=a&&l.colTo>=a)return!0}if(i.resolution<s.resolution){const[a,l,c,r]=e.spans.reduce((m,I)=>(m[0]=Math.min(m[0],I.row),m[1]=Math.max(m[1],I.row),m[2]=Math.min(m[2],I.colFrom),m[3]=Math.max(m[3],I.colTo),m),[1/0,-1/0,1/0,-1/0]),n=s.denormalizeCol(g.col,g.world),u=i.getColumnForX(s.getXForColumn(n)),d=i.getRowForY(s.getYForRow(g.row)),_=i.getColumnForX(s.getXForColumn(n+1))-1,w=i.getRowForY(s.getYForRow(g.row+1))-1;return!(u>r||_<c||d>l||w<a)}const o=i.denormalizeCol(g.col,g.world);return e.spans.some(a=>a.row===g.row&&a.colFrom<=o&&a.colTo>=o)}normalizeBounds(e,t,s){if(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],this._wrap){const i=G(this.tileInfo.spatialReference),o=-s*(i.valid[1]-i.valid[0]);e[0]+=o,e[2]+=o}return e}getSmallestInfoForScale(e){const t=this.scales;if(this._infoByScale[e])return this._infoByScale[e];if(e>t[0])return this._infoByScale[t[0]];for(let s=1;s<t.length-1;s++)if(e>t[s]+le)return this._infoByScale[t[s-1]];return this._infoByScale[t[t.length-1]]}getClosestInfoForScale(e){const t=this.scales;return this._infoByScale[e]||(e=t.reduce((s,i)=>Math.abs(i-e)<Math.abs(s-e)?i:s,t[0])),this._infoByScale[e]}scaleToLevel(e){const t=this.scales;if(this._infoByScale[e])return this._infoByScale[e].level;for(let s=t.length-1;s>=0;s--)if(e<t[s])return s===t.length-1?this._infoByScale[t[t.length-1]].level:this._infoByScale[t[s]].level+(t[s]-e)/(t[s]-t[s+1]);return this._infoByScale[t[0]].level}scaleToZoom(e){return this.tileInfo.scaleToZoom(e)}zoomToScale(e){return this.tileInfo.zoomToScale(e)}_getTileIdAtLOD(e,t,s){const i=this._infoByLevel[s.level];return e.set(s),t.resolution<i.resolution?null:(t.resolution===i.resolution||(e.level=t.level,e.col=Math.floor(s.col*i.resolution/t.resolution+.01),e.row=Math.floor(s.row*i.resolution/t.resolution+.01)),e)}};function re(h,e){return h.length=0,e.forEach(t=>h.push(t)),h}const O=new Set,V=[],L=new Map,j=[0,0];let z=class extends J{constructor(h){super(h),this._keyToItem=new Map,this.concurrency=6,this.strategy="scale-first",this.tileInfoView=null}initialize(){const{concurrency:h,process:e,strategy:t}=this;this._queue=new se({concurrency:h,process:(s,i)=>{const o=this._keyToItem.get(s);return e(o,{signal:i})},peeker:t==="scale-first"?s=>this._peekByScaleFirst(s):s=>this._peekByCenterFirst(s)})}destroy(){this.clear(),this._queue=U(this._queue)}get length(){return this._queue?this._queue.length:0}get onGoingCount(){return this._keyToItem.size}abort(h){const e=typeof h=="string"?h:h.id;this._queue.abort(e)}clear(){this._queue.clear(),this._keyToItem.clear()}has(h){return typeof h=="string"?this._keyToItem.has(h):this._keyToItem.has(h.id)}isOngoing(h){const e=typeof h=="string"?h:h.id;return this.has(e)&&this._queue.isOngoing(e)}pause(){this._queue.pause()}push(h){const e=h.key.id;if(this._queue.has(e))return this._queue.get(e);const t=this._queue.push(e),s=()=>{this._keyToItem.delete(e)};return this._keyToItem.set(e,h),t.then(s,s),t}reset(){this._queue.reset()}resume(){this._queue.resume()}_peekByScaleFirst(h){if(!this.state)return h.values().next().value;const e=this.tileInfoView;let t=Number.NEGATIVE_INFINITY,s=Number.POSITIVE_INFINITY;h.forEach(r=>{const n=this._keyToItem.get(r),u=this.tileInfoView.getTileScale(n.key);L.has(u)||(L.set(u,[]),t=Math.max(u,t),s=Math.min(u,s)),L.get(u).push(n.key),O.add(u)});let i=this.state.scale;L.has(i)||(re(V,O),V.sort((r,n)=>r-n),i=V.reduce((r,n)=>Math.abs(n-i)<Math.abs(r-i)?n:r,V[0])),i=Math.min(i,t),i=Math.max(i,s);const o=L.get(i),a=e.getClosestInfoForScale(i),l=a.getColumnForX(this.state.center[0]),c=a.getRowForY(this.state.center[1]);return o.sort((r,n)=>{const u=a.denormalizeCol(r.col,r.world),d=a.denormalizeCol(n.col,n.world);return Math.sqrt((l-u)*(l-u)+(c-r.row)*(c-r.row))-Math.sqrt((l-d)*(l-d)+(c-n.row)*(c-n.row))}),O.clear(),L.clear(),o[0].id}_peekByCenterFirst(h){if(!this.state)return h.values().next().value;const e=this.tileInfoView,t=this.state.center;let s,i=Number.POSITIVE_INFINITY;return h.forEach(o=>{const a=this._keyToItem.get(o);e.getTileCoords(j,a.key);const l=te(j,t);l<i&&(i=l,s=a.key)}),s.id}};R([q({constructOnly:!0})],z.prototype,"concurrency",void 0),R([q({constructOnly:!0})],z.prototype,"process",void 0),R([q()],z.prototype,"state",void 0),R([q({constructOnly:!0})],z.prototype,"strategy",void 0),R([q({constructOnly:!0})],z.prototype,"tileInfoView",void 0),z=R([H("esri.views.2d.tiling.TileQueue")],z);const me=z;class ne{constructor(e,t,s){this.maxSize=e,this._tileInfoView=t,this._removedFunc=s,this._tilePerId=new Map,this._tileKeysPerLevel=[]}clear(){this._tilePerId.clear(),this._tileKeysPerLevel=[]}has(e){return this._tilePerId.has(e)}get(e){return this._tilePerId.get(e)}pop(e){const t=this._tilePerId.get(e);if(!t)return;const s=t.key.level,i=this._tileKeysPerLevel[s];D(this._tilePerId,e);for(let o=0;o<i.length;o++)if(i[o].id===e){i.splice(o,1);break}return t.visible=!0,t}add(e){e.visible=!1;const t=e.key,s=t.id;if(this._tilePerId.has(s))return;this._tilePerId.set(s,e);const i=t.level;this._tileKeysPerLevel[i]||(this._tileKeysPerLevel[i]=[]),this._tileKeysPerLevel[i].push(t)}prune(e,t,s){let i=this._tilePerId.size;if(i<=this.maxSize)return;let o=this._tileKeysPerLevel.length-1;for(;i>this.maxSize&&o>=0;)o!==e&&(i=this._pruneAroundCenterTile(i,t,s,o)),o--;i>this.maxSize&&(i=this._pruneAroundCenterTile(i,t,s,e))}_pruneAroundCenterTile(e,t,s,i){const o=this._tileKeysPerLevel[i];if(!o||o.length===0)return e;const{size:a,origin:l}=this._tileInfoView.tileInfo,c=s*a[0],r=s*a[1],n=[0,0],u=[0,0];for(o.sort((d,_)=>(n[0]=l.x+c*(d.col+.5),n[1]=l.y-r*(d.row+.5),u[0]=l.x+c*(_.col+.5),u[1]=l.y-r*(_.row+.5),K(n,t)-K(u,t)));o.length>0;){const d=o.pop();if(this._removeTile(d.id),--e===this.maxSize)break}return e}_removeTile(e){const t=this._tilePerId.get(e);this._removedFunc&&t&&this._removedFunc(t),D(this._tilePerId,e)}}function D(h,e){h.delete(e)}const P=new Y(0,0,0,0),F=new Map,b=[],E=[];class ye{constructor(e){this._previousScale=Number.POSITIVE_INFINITY,this.cachePolicy="keep",this.coveragePolicy="closest",this.resampling=!0,this.tileIndex=new Map,this.tiles=[],this.buffer=192,this.acquireTile=e.acquireTile,this.releaseTile=e.releaseTile,this.tileInfoView=e.tileInfoView,e.resampling!=null&&(this.resampling=e.resampling),e.cachePolicy&&(this.cachePolicy=e.cachePolicy),e.coveragePolicy&&(this.coveragePolicy=e.coveragePolicy),e.buffer!=null&&(this.buffer=e.buffer),e.cacheSize&&(this._tileCache=new ne(e.cacheSize,this.tileInfoView,t=>{this.releaseTile(t)}))}destroy(){this.tileIndex.clear()}update(e){var f,y;const{resampling:t,tileIndex:s}=this,{scale:i,center:o,resolution:a}=e.state,{minScale:l,maxScale:c}=this.tileInfoView,r=!e.stationary&&i>this._previousScale;if(this._previousScale=i,!t&&(i>l||i<c))return this.tiles.length=0,void this.clear();const n=this.tileInfoView.getTileCoverage(e.state,this.buffer,this.resampling,this.coveragePolicy);if(!n)return this.tiles.length=0,void this.clear();const{spans:u,lodInfo:d}=n,{level:_}=d;this.tiles.length=0,s.forEach(p=>p.visible=!0);let w=0,m=0;if(u.length>0)for(const{row:p,colFrom:k,colTo:$}of u)for(let x=k;x<=$;x++){w++;const C=P.set(_,p,d.normalizeCol(x),d.getWorldForColumn(x)).id;let S=s.get(C);if(S)S.isReady?(F.set(C,S),m++):r||this._addParentTile(C,F);else{if((f=this._tileCache)!=null&&f.has(C)){if(S=this._tileCache.pop(C),this.tileIndex.set(C,S),S.isReady){F.set(C,S),m++;continue}}else S=this.acquireTile(P),this.tileIndex.set(C,S);r||this._addParentTile(C,F)}}const I=m===w;for(const[p,k]of s){if(F.has(p))continue;P.set(p);const $=this.tileInfoView.intersects(n,P),x=this.cachePolicy==="purge"?P.level!==_:P.level>_;!$||!r&&I?!x&&$||b.push(k):k.isReady?x&&this.cachePolicy==="purge"&&this._hasReadyAncestor(P,_)?b.push(k):E.push(k):x&&b.push(k)}for(const p of E)p.isReady&&F.set(p.key.id,p);for(const p of b)this._tileCache?this._tileCache.add(p):this.releaseTile(p),s.delete(p.key.id);for(const p of F.values())this.tiles.push(p);for(const p of s.values())F.has(p.key.id)||(p.visible=!1);(y=this._tileCache)==null||y.prune(_,o,a),A.pool.release(n),E.length=0,b.length=0,F.clear()}clear(){const{tileIndex:e}=this;for(const t of e.values())this.releaseTile(t);e.clear()}refresh(e){var t;for(const s of this.tileIndex.values())this.tiles.includes(s)?e(s):b.push(s);for(const s of b)this.releaseTile(s),this.tileIndex.delete(s.key.id);(t=this._tileCache)==null||t.clear()}updateCacheSize(e){this._tileCache&&(this._tileCache.maxSize=e)}_addParentTile(e,t){var o;let s=e,i=null;for(;s=this.tileInfoView.getTileParentId(s),s;)if(this.tileIndex.has(s)){if(i=this.tileIndex.get(s),i==null?void 0:i.isReady){t.has(i.key.id)||t.set(i.key.id,i);break}}else if((o=this._tileCache)!=null&&o.has(s)&&(i=this._tileCache.pop(s),this.tileIndex.set(s,i),i==null?void 0:i.isReady)){t.has(i.key.id)||t.set(i.key.id,i);break}}_hasReadyAncestor(e,t){const s=W();this.tileInfoView.getTileBounds(s,e,!0);for(const i of this.tileIndex.values())if(i.isReady&&i.key.level>=t&&i.key.level<e.level){const o=W();if(this.tileInfoView.getTileBounds(o,i.key,!0),ee(o,s))return!0}return!1}}export{de as h,me as m,ye as r,A as s};

import{go as T,p as C,U as X,e0 as W,I as _,i as B,aN as I,m as F,f0 as z,aJ as J,fK as E,n as G,s as H}from"./index-DX0rcHuW.js";import{r as q,o as A,i as R,s as D}from"./normalizeUtilsCommon-DXRtgGFh.js";import{f as Q}from"./utils-nzDIu46v.js";import{r as V,o as Y}from"./utils-D67OULxu.js";async function Z(e,n,l,s){const t=Q(e),r=n[0].spatialReference,i={...s,responseType:"json",query:{...t.query,f:"json",sr:T(r),target:JSON.stringify({geometryType:C(n[0]),geometries:n}),cutter:JSON.stringify(l)}},o=await X(t.path+"/cut",i),{cutIndexes:c,geometries:a=[]}=o.data;return{cutIndexes:c,geometries:a.map(u=>{const m=W(u);return m.spatialReference=r,m})}}async function ee(e,n,l){const s=typeof e=="string"?_(e):e,t=n[0].spatialReference,r=C(n[0]),i={...l,query:{...s.query,f:"json",sr:T(t),geometries:JSON.stringify(V(n))}},{data:o}=await X(s.path+"/simplify",i);return Y(o.geometries,r,t)}const K=()=>G.getLogger("esri.geometry.support.normalizeUtils");function te(e){return e.type==="polygon"}function ne(e){return e[0].type==="polygon"}function se(e){return e[0].type==="polyline"}function U(e){const n=[];let l=0,s=0;for(let t=0;t<e.length;t++){const r=e[t];let i=null;for(let o=0;o<r.length;o++)i=r[o],n.push(i),o===0?(l=i[0],s=l):(l=Math.min(l,i[0]),s=Math.max(s,i[0]));i&&n.push([(l+s)/2,0])}return n}function oe(e,n){if(!(e instanceof F||e instanceof J)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw K().error(t),new H(t)}const l=A(e),s=[];for(const t of l){const r=[];s.push(r),r.push([t[0][0],t[0][1]]);for(let i=0;i<t.length-1;i++){const o=t[i][0],c=t[i][1],a=t[i+1][0],u=t[i+1][1],m=Math.sqrt((a-o)*(a-o)+(u-c)*(u-c)),p=(u-c)/m,d=(a-o)/m,g=m/n;if(g>1){for(let b=1;b<=g-1;b++){const N=b*n,f=d*N+o,h=p*N+c;r.push([f,h])}const w=(m+Math.floor(g-1)*n)/2,j=d*w+o,S=p*w+c;r.push([j,S])}r.push([a,u])}}return te(e)?new J({rings:s,spatialReference:e.spatialReference}):new F({paths:s,spatialReference:e.spatialReference})}function k(e,n,l){if(n){const s=oe(e,1e6);e=E(s,!0)}return l&&(e=D(e,l)),e}function O(e,n,l){if(Array.isArray(e)){const s=e[0];if(s>n){const t=R(s,n);e[0]=s+t*(-2*n)}else if(s<l){const t=R(s,l);e[0]=s+t*(-2*l)}}else{const s=e.x;if(s>n){const t=R(s,n);e=e.clone().offset(t*(-2*n),0)}else if(s<l){const t=R(s,l);e=e.clone().offset(t*(-2*l),0)}}return e}function ie(e,n){let l=-1;for(let s=0;s<n.cutIndexes.length;s++){const t=n.cutIndexes[s],r=n.geometries[s],i=A(r);for(let o=0;o<i.length;o++){const c=i[o];c.some(a=>{if(a[0]<180)return!0;{let u=0;for(let p=0;p<c.length;p++){const d=c[p][0];u=d>u?d:u}u=Number(u.toFixed(9));const m=-360*R(u,180);for(let p=0;p<c.length;p++){const d=r.getPoint(o,p);r.setPoint(o,p,d.clone().offset(m,0))}return!0}})}if(t===l){if(ne(e))for(const o of A(r))e[t]=e[t].addRing(o);else if(se(e))for(const o of A(r))e[t]=e[t].addPath(o)}else l=t,e[t]=r}return e}async function re(e,n,l){if(!Array.isArray(e))return re([e],n);n&&typeof n!="string"&&K().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const s=typeof n=="string"?n:(n==null?void 0:n.url)??B.geometryServiceUrl;let t,r,i,o,c,a,u,m,p=0;const d=[],g=[];for(const f of e)if(f!=null)if(t||(t=f.spatialReference,r=I(t),i=t.isWebMercator,a=i?102100:4326,o=q[a].maxX,c=q[a].minX,u=q[a].plus180Line,m=q[a].minus180Line),r)if(f.type==="mesh")g.push(f);else if(f.type==="point")g.push(O(f.clone(),o,c));else if(f.type==="multipoint"){const h=f.clone();h.points=h.points.map(x=>O(x,o,c)),g.push(h)}else if(f.type==="extent"){const h=f.clone()._normalize(!1,!1,r);g.push(h.rings?new J(h):h)}else if(f.extent){const h=f.extent,x=R(h.xmin,c)*(2*o);let M=x===0?f.clone():D(f.clone(),x);h.offset(x,0);let{xmin:$,xmax:y}=h;$=Number($.toFixed(9)),y=Number(y.toFixed(9)),h.intersects(u)&&y!==o?(p=y>p?y:p,M=k(M,i),d.push(M),g.push("cut")):h.intersects(m)&&$!==c?(p=y*(2*o)>p?y*(2*o):p,M=k(M,i,360),d.push(M),g.push("cut")):g.push(M)}else g.push(f.clone());else g.push(f);else g.push(f);let w=R(p,o),j=-90;const S=w,b=new F;for(;w>0;){const f=360*w-180;b.addPath([[f,j],[f,-1*j]]),j*=-1,w--}if(d.length>0&&S>0){const f=ie(d,await Z(s,d,b,l)),h=[],x=[];for(let y=0;y<g.length;y++){const v=g[y];if(v!=="cut")x.push(v);else{const P=f.shift(),L=e[y];L!=null&&L.type==="polygon"&&L.rings&&L.rings.length>1&&P.rings.length>=L.rings.length?(h.push(P),x.push("simplify")):x.push(i?z(P):P)}}if(!h.length)return x;const M=await ee(s,h,l),$=[];for(let y=0;y<x.length;y++){const v=x[y];v!=="simplify"?$.push(v):$.push(i?z(M.shift()):M.shift())}return $}const N=[];for(let f=0;f<g.length;f++){const h=g[f];if(h!=="cut")N.push(h);else{const x=d.shift();N.push(i===!0?z(x):x)}}return N}function ue(e){if(!e)return null;const n=e.extent;if(!n)return null;const l=e.spatialReference&&I(e.spatialReference);if(!l)return n;const[s,t]=l.valid,r=2*t,{width:i}=n;let o,{xmin:c,xmax:a}=n;if([c,a]=[a,c],e.type==="extent"||i===0||i<=t||i>r||c<s||a>t)return n;switch(e.type){case"polygon":if(!(e.rings.length>1))return n;o=U(e.rings);break;case"polyline":if(!(e.paths.length>1))return n;o=U(e.paths);break;case"multipoint":o=e.points}const u=n.clone();for(let m=0;m<o.length;m++){let p=o[m][0];p<0?(p+=t,a=Math.max(p,a)):(p-=t,c=Math.min(p,c))}return u.xmin=c,u.xmax=a,u.width<i?(u.xmin-=t,u.xmax-=t,u):n}function pe(e,n,l){const s=I(l);if(s==null)return e;const[t,r]=s.valid,i=2*r;let o=0,c=0;n>r?o=Math.ceil(Math.abs(n-r)/i):n<t&&(o=-Math.ceil(Math.abs(n-t)/i)),e>r?c=Math.ceil(Math.abs(e-r)/i):e<t&&(c=-Math.ceil(Math.abs(e-t)/i));let a=e+(o-c)*i;const u=a-n;return u>r?a-=i:u<t&&(a+=i),a}function he(e,n){const l=I(n);if(l){const[s,t]=l.valid,r=t-s;if(e<s)for(;e<s;)e+=r;if(e>t)for(;e>t;)e-=r}return e}export{he as L,oe as M,pe as P,re as R,ue as v};
